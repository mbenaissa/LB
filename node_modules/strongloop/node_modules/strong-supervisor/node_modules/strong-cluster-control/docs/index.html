<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/code-themes/sl-theme.css">
        <link rel="stylesheet" href="css/main.css">
    </head>
    <body>
        <div class="navbar navbar-inverse navbar-static-top" role="navigation">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">docs.strongloop.com</a>
            </div>
            <div class="navbar-collapse">
            </div>
        </div>

<div class="row">
  <div class="col-lg-3 column scroll-spy-target">
    <ul class="nav nav-pills nav-stacked">
  
    <li class="depth-1">
      <a href="#run-time-management-of-a-node-cluster">Run-Time Management of a Node Cluster</a>
    </li>
  
    <li class="depth-2">
      <a href="#install">Install</a>
    </li>
  
    <li class="depth-2">
      <a href="#example">Example</a>
    </li>
  
    <li class="depth-2">
      <a href="#overview">Overview</a>
    </li>
  
    <li class="depth-2">
      <a href="#methods">Methods</a>
    </li>
  
    <li class="depth-3">
      <a href="#control-startoptionscallback">control.start</a>
    </li>
  
    <li class="depth-3">
      <a href="#control-stopcallback">control.stop</a>
    </li>
  
    <li class="depth-3">
      <a href="#control-restart">control.restart</a>
    </li>
  
    <li class="depth-3">
      <a href="#control-loadoptionsdefaults">control.loadOptions</a>
    </li>
  
    <li class="depth-3">
      <a href="#control-status">control.status</a>
    </li>
  
    <li class="depth-3">
      <a href="#control-setsizen">control.setSize</a>
    </li>
  
    <li class="depth-3">
      <a href="#control-shutdownid">control.shutdown</a>
    </li>
  
    <li class="depth-3">
      <a href="#control-terminateid">control.terminate</a>
    </li>
  
    <li class="depth-2">
      <a href="#properties">Properties</a>
    </li>
  
    <li class="depth-3">
      <a href="#control-options">control.options</a>
    </li>
  
    <li class="depth-3">
      <a href="#control-cmd-shutdown">control.cmd.SHUTDOWN</a>
    </li>
  
    <li class="depth-3">
      <a href="#control-cpus">control.CPUS</a>
    </li>
  
    <li class="depth-2">
      <a href="#events">Events</a>
    </li>
  
    <li class="depth-3">
      <a href="#start">&#39;start&#39;</a>
    </li>
  
    <li class="depth-3">
      <a href="#stop">&#39;stop&#39;</a>
    </li>
  
    <li class="depth-3">
      <a href="#error">&#39;error&#39;</a>
    </li>
  
    <li class="depth-3">
      <a href="#setsize">&#39;setSize&#39;</a>
    </li>
  
    <li class="depth-3">
      <a href="#resize">&#39;resize&#39;</a>
    </li>
  
    <li class="depth-3">
      <a href="#startworker">&#39;startWorker&#39;</a>
    </li>
  
    <li class="depth-3">
      <a href="#startrestart">&#39;startRestart&#39;</a>
    </li>
  
    <li class="depth-3">
      <a href="#restart">&#39;restart&#39;</a>
    </li>
  
    <li class="depth-3">
      <a href="#stopworker">&#39;stopWorker&#39;</a>
    </li>
  
</ul>

  </div>
  <div class="col-lg-9 col-lg-offset-3 column" data-spy="scroll" data-target=".scroll-spy-target" data-offset="0">
    <div class="readability">
      
        <a name="run-time-management-of-a-node-cluster"></a><h1 id="run-time-management-of-a-node-cluster">Run-Time Management of a Node Cluster <small>v1.0.0</small></h1>
<p>Module for run-time management of a node cluster.</p>
<p>It is an extension of the node cluster module, not a replacement.</p>
<p>An alternative to integrating strong-cluster-control into an application using
the API is to use
<a href="https://github.com/strongloop/strong-supervisor">strong-supervisor</a>, a
runner-based wrapper that requires no code changes.</p>
<p>For full documentation, see 
<a href="http://docs.strongloop.com/display/SLC/Application+clustering">StrongLoop Documentation</a>.</p>
<ul>
<li>runs <code>size</code> workers (optionally), and monitors them for unexpected death</li>
<li>run-time control of cluster through command line and API</li>
<li>soft shutdown as well as hard termination of workers</li>
<li>throttles worker restart rate if they are exiting abnormally</li>
</ul>
<p>It can be added to an existing application using the node cluster module without
modifying how that application is currently starting up or using cluster, and
still make use of additional features.</p>
<a name="install"></a><h2 id="install">Install</h2>
<pre><code>npm install --save strong-cluster-control</code></pre>
<a name="example"></a><h2 id="example">Example</h2>
<p>To instantiate cluster-control:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> cluster = require(<span class="string">'cluster'</span>);
<span class="keyword">var</span> control = require(<span class="string">'strong-cluster-control'</span>);

<span class="comment">// global setup here...</span>

control.start({
    size: control.CPUS
}).on(<span class="string">'error'</span>, <span class="keyword">function</span>(er) {
    console.error(er);
});

<span class="keyword">if</span>(cluster.isWorker) {
    <span class="comment">// do work here...</span>
}</code></pre>
<p>For more in-depth examples, see the
<a href="https://github.com/strongloop/strong-cluster-control/blob/master/bin/example-master.js">in-source example</a>,
or use <a href="https://github.com/strongloop/strong-supervisor">strong-supervisor</a>.</p>

      
        <a name="overview"></a><h2 id="overview">Overview</h2>
<p>The controller is exported by the <code>strong-cluster-control</code> module.</p>
<pre><code>control = require(&#39;strong-cluster-control&#39;)</code></pre>
<a name="methods"></a><h2 id="methods">Methods</h2>
<a name="control-startoptionscallback"></a><h3 id="control-start-options-callback-">control.start([options],[callback])</h3>
<p>Start the controller.</p>
<ul>
<li><code>options</code>: {Object} An options object, see below for supported properties,
no default, and options object is not required.</li>
<li><code>callback</code>: {Function} A callback function, it is set as a listener for
the <code>&#39;start&#39;</code> event.</li>
</ul>
<p>The options are:</p>
<ul>
<li><p><code>size</code>: {Integer} Number of workers that should be running, the default
is to <em>not</em> control the number of workers, see <code>setSize()</code></p>
</li>
<li><p><code>env</code>: {Object} Environment properties object passed to <code>cluster.fork()</code> if
the controller has to start a worker to resize the cluster, default is null.</p>
</li>
<li><p><code>shutdownTimeout</code>: {Milliseconds} Number of milliseconds to wait after
shutdown before terminating a worker, the default is 5 seconds, see
<code>.shutdown()</code></p>
</li>
<li><code>terminateTimeout</code>: {Milliseconds} Number of milliseconds to wait after
terminate before killing a worker, the default is 5 seconds, see
<code>.terminate()</code></li>
<li><code>throttleDelay</code>: {Milliseconds} Number of milliseconds to delay restarting
 workers after they are exiting abnormally.  Abnormal is defined as
 as <em>not</em> suicide, see <code>worker.suicide</code> in
 <a href="http://nodejs.org/docs/latest/api/cluster.html">cluster docs</a></li>
</ul>
<p>For convenience during setup, it is not necessary to wrap <code>.start()</code> in a protective
conditional <code>if(cluster.isMaster) {control.start()}</code>, when called in workers it quietly
does nothing but call its callback.</p>
<p>The &#39;start&#39; event is emitted after the controller is started.</p>
<a name="control-stopcallback"></a><h3 id="control-stop-callback-">control.stop([callback])</h3>
<p>Stop the controller, after stopping workers (if the size is being controlled,
see <code>setSize()</code>).</p>
<p>Remove event listeners that were set on the <code>cluster</code> module.</p>
<ul>
<li><code>callback</code>: {Function} A callback function, it is set as a listener for
the <code>&#39;stop&#39;</code> event.</li>
</ul>
<p>The &#39;stop&#39; event is emitted after the controller is stopped.</p>
<p>When there are no workers or listeners, node will exit, unless the application
has non-cluster handles open. Open handles can be closed in the &#39;stop&#39; event
callback to allow node to shutdown gracefully, or <code>process.exit()</code> can be
called, as appropriate for the application.</p>
<a name="control-restart"></a><h3 id="control-restart-">control.restart()</h3>
<p>Restart workers one by one, until all current workers have been restarted.</p>
<p>This can be used to do a rolling upgrade, if the underlying code has changed.</p>
<p>Old workers will be restarted only if the last worker to be restarted stays
alive for more than <code>throttleDelay</code> milliseconds, ensuring that the current
workers will not all be killed while the new workers are failing to start.</p>
<a name="control-loadoptionsdefaults"></a><h3 id="control-loadoptions-defaults-">control.loadOptions([defaults])</h3>
<p>Load options from configuration files, environment, or command line.</p>
<ul>
<li><code>defaults</code>: {Object} Default options, see <code>start()</code> for description
of supported options.</li>
</ul>
<p>An options object is returned that is suitable for passing directly to
<code>start()</code>. How you use it is up to you, but it can be conveniently used to
implement optionally clustered applications, ones that run unclustered when
deployed as single instances, perhaps behind a load balancer, or that can be
deployed as a node cluster.</p>
<p>Here is an example of the above usage pattern:</p>
<pre><code>// app.js
var control = require(&#39;strong-cluster-control&#39;);
var options = control.loadOptions();
if(options.clustered &amp;&amp; options.isMaster) {
    return control.start(options);
}

// Server setup... or any work that should be done in the master if
// the application is not being clustered, or in the worker if it
// is being clustered.</code></pre>
<p>The options values are derived from the following configuration sources:</p>
<ul>
<li>command line arguments (parsed by optimist): if your app ignores unknown
options, options can be set on the command line, ex. <code>node app.js --size=2</code></li>
<li>environment variables prefixed with <code>cluster_</code>: note that the variable must be
lower case, ex. <code>cluster_size=2 node app.js</code></li>
<li><code>.clusterrc</code> in either json or ini format: can be in the current working
directory, or any parent paths</li>
<li><code>defaults</code>: as passed in, if any</li>
</ul>
<p>This is actually a subset of the possible locations, the
<a href="https://npmjs.org/package/rc">rc</a> module is used with an <code>appname</code> of
&quot;cluster&quot;, see it&#39;s documentation for more information.</p>
<p>Supported values are those described in <code>start()</code>, with a few extensions for
<code>size</code>, which may be one of:</p>
<ol>
<li><code>0</code> - <code>N</code>, a positive integer, cluster size to maintain, as for <code>start()</code></li>
<li><code>&quot;default&quot;</code>, or a string containing <code>&quot;cpu&quot;</code>, this will be converted to the
number of cpus, see <code>control.CPUS</code></li>
<li><code>&quot;off&quot;</code>, or anything else that isn&#39;t one of the previous values will indicate
a preference for <em>not</em> clustering</li>
</ol>
<p>The returned options object will contain the following fields that are not
options to <code>start()</code>:</p>
<ul>
<li>clustered: false if size is 0 (after above conversions), true if a cluster
size was specified</li>
<li>isMaster, isWorker: identical to the properties of the same name in the
cluster module</li>
</ul>
<p>The combination of the above three allows you to determine if you are a worker,
or not, and if you are a master, if you should start the cluster control module,
or just start the server if clustering was not requested.</p>
<a name="control-status"></a><h3 id="control-status-">control.status()</h3>
<p>Returns the current cluster status. Its properties include:</p>
<ul>
<li><code>master</code>: {Object}<ul>
<li><code>pid</code>: The pid of the Master process.</li>
</ul>
</li>
<li><code>workers</code>: {Array} An Array of Objects containining the following properties:<ul>
<li><code>id</code>: The id of the Worker within the Master.</li>
<li><code>pid</code>: The pid of the Worker process.</li>
</ul>
</li>
</ul>
<a name="control-setsizen"></a><h3 id="control-setsize-n-">control.setSize(N)</h3>
<p>Set the size of the cluster.</p>
<ul>
<li><code>N</code>: {Integer or null} The size of the cluster is the number of workers
that should be maintained online. A size of <code>null</code> clears the size, and
disables the size control feature of the controller.</li>
</ul>
<p>The cluster size can be set explicitly with <code>setSize()</code>, or implicitly through
the <code>options</code> provided to <code>.start()</code>, or through the control channel.</p>
<p>The size cannot be set until the controller has been started, and will not be
maintained after the cluster has stopped.</p>
<p>Once set, the controller will listen on cluster <code>fork</code> and <code>exit</code> events,
and resize the cluster back to the set size if necessary. After the cluster has
been resized, the &#39;resize&#39; event will be emitted.</p>
<p>When a resize is necessary, workers will be started or stopped one-by-one until
the cluster is the set size.</p>
<p>Cluster workers are started with <code>cluster.fork(control.options.env)</code>, so the
environment can be set, but must be the same for each worker. After a worker has
been started, the &#39;startWorker&#39; event will be emitted.</p>
<p>Cluster workers are stopped with <code>.shutdown()</code>. After a worker has been stopped,
the &#39;stopWorker&#39; event will be emitted.</p>
<a name="control-shutdownid"></a><h3 id="control-shutdown-id-">control.shutdown(id)</h3>
<p>Disconnect worker <code>id</code> and take increasingly agressive action until it exits.</p>
<ul>
<li><code>id</code> {Number} Cluster worker ID, see <code>cluster.workers</code> in
<a href="http://nodejs.org/docs/latest/api/cluster.html">cluster docs</a></li>
</ul>
<p>The effect of disconnect on a worker is to close all the servers in the worker,
wait for them to close, and then exit. This process may not occur in a timely
fashion if, for example, the server connections do not close. In order to
gracefully close any open connections, a worker may listen to the <code>SHUTDOWN</code>
message, see <code>control.cmd.SHUTDOWN</code>.</p>
<p>Sends a <code>SHUTDOWN</code> message to the identified worker, calls
<code>worker.disconnect()</code>, and sets a timer for <code>control.options.shutdownTimeout</code>.
If the worker has not exited by that time, calls <code>.terminate()</code> on the worker.</p>
<a name="control-terminateid"></a><h3 id="control-terminate-id-">control.terminate(id)</h3>
<p>Terminate worker <code>id</code>, taking increasingly aggressive action until it exits.</p>
<ul>
<li><code>id</code> {Number} Cluster worker ID, see <code>cluster.workers</code> in
<a href="http://nodejs.org/docs/latest/api/cluster.html">cluster docs</a></li>
</ul>
<p>The effect of sending SIGTERM to a node process should be to cause it to exit.
This may not occur in a timely fashion if, for example, the process is ignoring
SIGTERM, or busy looping.</p>
<p>Calls <code>worker.kill(&quot;SIGTERM&quot;)</code> on the identified worker, and sets a timer for
<code>control.options.terminateTimeout</code>. If the worker has not exited by that time,
calls <code>worker.(&quot;SIGKILL&quot;)</code> on the worker.</p>
<a name="properties"></a><h2 id="properties">Properties</h2>
<a name="control-options"></a><h3 id="control-options">control.options</h3>
<p>A copy of the options set by calling <code>.start()</code>.</p>
<p>It will have any default values set in it, and will be kept synchronized with
changes made via explicit calls, such as to <code>.setSize()</code>.</p>
<p>Visible for diagnostic and logging purposes.  Do <em>not</em> modify the options
directly.</p>
<a name="control-cmd-shutdown"></a><h3 id="control-cmd-shutdown">control.cmd.SHUTDOWN</h3>
<ul>
<li>{String} <code>&#39;CLUSTER_CONTROL_shutdown&#39;</code></li>
</ul>
<p>The <code>SHUTDOWN</code> message is sent by <code>.shutdown()</code> before disconnecting the worker,
and can be used to gracefully close any open connections before the
<code>control.options.shutdownTimeout</code> expires.</p>
<p>All connections will be closed at the TCP level when the worker exits or is
terminated, but this message gives the opportunity to close at a more
application-appropriate time, for example, after any outstanding requests have
been completed.</p>
<p>The message format is:</p>
<pre><code>{ cmd: control.cmd.SHUTDOWN }</code></pre>
<p>It can be received in a worker by listening for a <code>&#39;message&#39;</code> event with a
matching <code>cmd</code> property:</p>
<pre><code>process.on(&#39;message&#39;, function(msg) {
    if(msg.cmd === control.cmd.SHUTDOWN) {
        // Close any open connections as soon as they are idle...
    }
});</code></pre>
<a name="control-cpus"></a><h3 id="control-cpus">control.CPUS</h3>
<p>The number of CPUs reported by node&#39;s <code>os.cpus().length</code>, this is a good default
for the cluster size, in the absence of application specific analysis of what
would be an optimal number of workers.</p>
<a name="events"></a><h2 id="events">Events</h2>
<a name="start"></a><h3 id="-start-">&#39;start&#39;</h3>
<p>Event emitted after control has started. Control is considered started
after the &#39;listening&#39; event has been emitted.</p>
<p>Starting of workers happens in the background, if you are specifically
interested in knowing when all the workers have started, see the &#39;resize&#39;
event.</p>
<a name="stop"></a><h3 id="-stop-">&#39;stop&#39;</h3>
<p>Event emitted after control has stopped, see <code>.stop()</code>.</p>
<a name="error"></a><h3 id="-error-">&#39;error&#39;</h3>
<ul>
<li>{Error Object}</li>
</ul>
<p>Event emitted when an error occurs. The only current source of errors is the control
protocol, which may require logging of the errors, but should not effect the
operation of the controller.</p>
<a name="setsize"></a><h3 id="-setsize-">&#39;setSize&#39;</h3>
<ul>
<li>{Integer} size, the number of workers requested (will always
be the same as <code>cluster.options.size</code>)</li>
</ul>
<p>Event emitted after <code>setSize()</code> is called.</p>
<a name="resize"></a><h3 id="-resize-">&#39;resize&#39;</h3>
<ul>
<li>{Integer} size, the number of workers now that resize is complete (will always
be the same as <code>cluster.options.size</code>)</li>
</ul>
<p>Event emitted after a resize of the cluster is complete. At this point, no more
workers will be forked or shutdown by the controller until either the size is
changed or workers fork or exit, see <code>setSize()</code>.</p>
<a name="startworker"></a><h3 id="-startworker-">&#39;startWorker&#39;</h3>
<ul>
<li><code>worker</code> {Worker object}</li>
</ul>
<p>Event emitted after a worker which was started during a resize comes online, see the
node API documentation for description of <code>worker</code> and &quot;online&quot;.</p>
<a name="startrestart"></a><h3 id="-startrestart-">&#39;startRestart&#39;</h3>
<ul>
<li><code>workers</code> {Array of worker IDs} Workers that are going to be restarted.</li>
</ul>
<p>Event emitted after <code>restart()</code> is called with array of worker IDs that will be
restarted.</p>
<a name="restart"></a><h3 id="-restart-">&#39;restart&#39;</h3>
<p>Event emitted after after all the workers have been restarted.</p>
<a name="stopworker"></a><h3 id="-stopworker-">&#39;stopWorker&#39;</h3>
<ul>
<li><code>worker</code> {Worker object}</li>
<li><code>code</code> {Number} the exit code, if it exited normally.</li>
<li><code>signal</code> {String} the name of the signal if it exited due to signal</li>
</ul>
<p>Event emitted after a worker which was shutdown during a resize exits, see the node
API documentation for a description of <code>worker</code>.</p>
<p>The values of <code>code</code> and <code>signal</code>, as well as of <code>worker.suicide</code>, can be used
to determine how gracefully the worker was stopped. See <code>.terminate()</code>.</p>

      
    </div>
    <div class="intentionally-left-blank"></div>
  </div>
</div>
        <script src="js/vendor/jquery-1.10.1.min.js"></script>
        <script src="js/vendor/jquery.scrollTo-1.4.3.1.js"></script>
        <script src="js/vendor/bootstrap.min.js"></script>
        <script src="js/main.js"></script>
    </body>
</html>

