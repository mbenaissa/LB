{ content: 
   [ { docs: [Circular],
       file: '/home/sam/w/sn/strong-cluster-control/api.md',
       isJS: false,
       markedOptions: [Object],
       contents: '## Overview\n\nThe controller is exported by the `strong-cluster-control` module.\n\n    control = require(\'strong-cluster-control\')\n\n## Methods\n\n### control.start([options],[callback])\n\nStart the controller.\n\n* `options`: {Object} An options object, see below for supported properties,\n  no default, and options object is not required.\n* `callback`: {Function} A callback function, it is set as a listener for\n  the `\'start\'` event.\n\nThe options are:\n\n* `size`: {Integer} Number of workers that should be running, the default\n  is to *not* control the number of workers, see `setSize()`\n\n* `env`: {Object} Environment properties object passed to `cluster.fork()` if\n  the controller has to start a worker to resize the cluster, default is null.\n\n* `shutdownTimeout`: {Milliseconds} Number of milliseconds to wait after\n  shutdown before terminating a worker, the default is 5 seconds, see\n  `.shutdown()`\n* `terminateTimeout`: {Milliseconds} Number of milliseconds to wait after\n  terminate before killing a worker, the default is 5 seconds, see\n  `.terminate()`\n* `throttleDelay`: {Milliseconds} Number of milliseconds to delay restarting\n   workers after they are exiting abnormally.  Abnormal is defined as\n   as *not* suicide, see `worker.suicide` in\n   [cluster docs](http://nodejs.org/docs/latest/api/cluster.html)\n\nFor convenience during setup, it is not necessary to wrap `.start()` in a protective\nconditional `if(cluster.isMaster) {control.start()}`, when called in workers it quietly\ndoes nothing but call its callback.\n\nThe \'start\' event is emitted after the controller is started.\n\n### control.stop([callback])\n\nStop the controller, after stopping workers (if the size is being controlled,\nsee `setSize()`).\n\nRemove event listeners that were set on the `cluster` module.\n\n* `callback`: {Function} A callback function, it is set as a listener for\n  the `\'stop\'` event.\n\nThe \'stop\' event is emitted after the controller is stopped.\n\nWhen there are no workers or listeners, node will exit, unless the application\nhas non-cluster handles open. Open handles can be closed in the \'stop\' event\ncallback to allow node to shutdown gracefully, or `process.exit()` can be\ncalled, as appropriate for the application.\n\n### control.restart()\n\nRestart workers one by one, until all current workers have been restarted.\n\nThis can be used to do a rolling upgrade, if the underlying code has changed.\n\nOld workers will be restarted only if the last worker to be restarted stays\nalive for more than `throttleDelay` milliseconds, ensuring that the current\nworkers will not all be killed while the new workers are failing to start.\n\n### control.loadOptions([defaults])\n\nLoad options from configuration files, environment, or command line.\n\n* `defaults`: {Object} Default options, see `start()` for description\n  of supported options.\n\nAn options object is returned that is suitable for passing directly to\n`start()`. How you use it is up to you, but it can be conveniently used to\nimplement optionally clustered applications, ones that run unclustered when\ndeployed as single instances, perhaps behind a load balancer, or that can be\ndeployed as a node cluster.\n\nHere is an example of the above usage pattern:\n\n    // app.js\n    var control = require(\'strong-cluster-control\');\n    var options = control.loadOptions();\n    if(options.clustered && options.isMaster) {\n        return control.start(options);\n    }\n\n    // Server setup... or any work that should be done in the master if\n    // the application is not being clustered, or in the worker if it\n    // is being clustered.\n\nThe options values are derived from the following configuration sources:\n\n- command line arguments (parsed by optimist): if your app ignores unknown\n  options, options can be set on the command line, ex. `node app.js --size=2`\n- environment variables prefixed with `cluster_`: note that the variable must be\n  lower case, ex. `cluster_size=2 node app.js`\n- `.clusterrc` in either json or ini format: can be in the current working\n  directory, or any parent paths\n- `defaults`: as passed in, if any\n\nThis is actually a subset of the possible locations, the\n[rc](https://npmjs.org/package/rc) module is used with an `appname` of\n"cluster", see it\'s documentation for more information.\n\nSupported values are those described in `start()`, with a few extensions for\n`size`, which may be one of:\n\n1. `0` - `N`, a positive integer, cluster size to maintain, as for `start()`\n2. `"default"`, or a string containing `"cpu"`, this will be converted to the\n   number of cpus, see `control.CPUS`\n3. `"off"`, or anything else that isn\'t one of the previous values will indicate\n   a preference for *not* clustering\n\nThe returned options object will contain the following fields that are not\noptions to `start()`:\n\n- clustered: false if size is 0 (after above conversions), true if a cluster\n  size was specified\n- isMaster, isWorker: identical to the properties of the same name in the\n  cluster module\n\nThe combination of the above three allows you to determine if you are a worker,\nor not, and if you are a master, if you should start the cluster control module,\nor just start the server if clustering was not requested.\n\n### control.status()\n\nReturns the current cluster status. Its properties include:\n\n - `master`: {Object}\n   - `pid`: The pid of the Master process.\n - `workers`: {Array} An Array of Objects containining the following properties:\n    - `id`: The id of the Worker within the Master.\n    - `pid`: The pid of the Worker process.\n\n### control.setSize(N)\n\nSet the size of the cluster.\n\n* `N`: {Integer or null} The size of the cluster is the number of workers\n  that should be maintained online. A size of `null` clears the size, and\n  disables the size control feature of the controller.\n\nThe cluster size can be set explicitly with `setSize()`, or implicitly through\nthe `options` provided to `.start()`, or through the control channel.\n\nThe size cannot be set until the controller has been started, and will not be\nmaintained after the cluster has stopped.\n\nOnce set, the controller will listen on cluster `fork` and `exit` events,\nand resize the cluster back to the set size if necessary. After the cluster has\nbeen resized, the \'resize\' event will be emitted.\n\nWhen a resize is necessary, workers will be started or stopped one-by-one until\nthe cluster is the set size.\n\nCluster workers are started with `cluster.fork(control.options.env)`, so the\nenvironment can be set, but must be the same for each worker. After a worker has\nbeen started, the \'startWorker\' event will be emitted.\n\nCluster workers are stopped with `.shutdown()`. After a worker has been stopped,\nthe \'stopWorker\' event will be emitted.\n\n### control.shutdown(id)\n\nDisconnect worker `id` and take increasingly agressive action until it exits.\n\n* `id` {Number} Cluster worker ID, see `cluster.workers` in\n  [cluster docs](http://nodejs.org/docs/latest/api/cluster.html)\n\nThe effect of disconnect on a worker is to close all the servers in the worker,\nwait for them to close, and then exit. This process may not occur in a timely\nfashion if, for example, the server connections do not close. In order to\ngracefully close any open connections, a worker may listen to the `SHUTDOWN`\nmessage, see `control.cmd.SHUTDOWN`.\n\nSends a `SHUTDOWN` message to the identified worker, calls\n`worker.disconnect()`, and sets a timer for `control.options.shutdownTimeout`.\nIf the worker has not exited by that time, calls `.terminate()` on the worker.\n\n### control.terminate(id)\n\nTerminate worker `id`, taking increasingly aggressive action until it exits.\n\n* `id` {Number} Cluster worker ID, see `cluster.workers` in\n  [cluster docs](http://nodejs.org/docs/latest/api/cluster.html)\n\nThe effect of sending SIGTERM to a node process should be to cause it to exit.\nThis may not occur in a timely fashion if, for example, the process is ignoring\nSIGTERM, or busy looping.\n\nCalls `worker.kill("SIGTERM")` on the identified worker, and sets a timer for\n`control.options.terminateTimeout`. If the worker has not exited by that time,\ncalls `worker.("SIGKILL")` on the worker.\n\n## Properties\n\n### control.options\n\nA copy of the options set by calling `.start()`.\n\nIt will have any default values set in it, and will be kept synchronized with\nchanges made via explicit calls, such as to `.setSize()`.\n\nVisible for diagnostic and logging purposes.  Do *not* modify the options\ndirectly.\n\n### control.cmd.SHUTDOWN\n\n* {String} `\'CLUSTER_CONTROL_shutdown\'`\n\nThe `SHUTDOWN` message is sent by `.shutdown()` before disconnecting the worker,\nand can be used to gracefully close any open connections before the\n`control.options.shutdownTimeout` expires.\n\nAll connections will be closed at the TCP level when the worker exits or is\nterminated, but this message gives the opportunity to close at a more\napplication-appropriate time, for example, after any outstanding requests have\nbeen completed.\n\nThe message format is:\n\n    { cmd: control.cmd.SHUTDOWN }\n\nIt can be received in a worker by listening for a `\'message\'` event with a\nmatching `cmd` property:\n\n    process.on(\'message\', function(msg) {\n        if(msg.cmd === control.cmd.SHUTDOWN) {\n            // Close any open connections as soon as they are idle...\n        }\n    });\n\n### control.CPUS\n\nThe number of CPUs reported by node\'s `os.cpus().length`, this is a good default\nfor the cluster size, in the absence of application specific analysis of what\nwould be an optimal number of workers.\n\n## Events\n\n### \'start\'\n\nEvent emitted after control has started. Control is considered started\nafter the \'listening\' event has been emitted.\n\nStarting of workers happens in the background, if you are specifically\ninterested in knowing when all the workers have started, see the \'resize\'\nevent.\n\n### \'stop\'\n\nEvent emitted after control has stopped, see `.stop()`.\n\n### \'error\'\n\n* {Error Object}\n\nEvent emitted when an error occurs. The only current source of errors is the control\nprotocol, which may require logging of the errors, but should not effect the\noperation of the controller.\n\n### \'setSize\'\n\n* {Integer} size, the number of workers requested (will always\n  be the same as `cluster.options.size`)\n\nEvent emitted after `setSize()` is called.\n\n### \'resize\'\n\n* {Integer} size, the number of workers now that resize is complete (will always\n  be the same as `cluster.options.size`)\n\nEvent emitted after a resize of the cluster is complete. At this point, no more\nworkers will be forked or shutdown by the controller until either the size is\nchanged or workers fork or exit, see `setSize()`.\n\n### \'startWorker\'\n\n* `worker` {Worker object}\n\nEvent emitted after a worker which was started during a resize comes online, see the\nnode API documentation for description of `worker` and "online".\n\n### \'startRestart\'\n\n* `workers` {Array of worker IDs} Workers that are going to be restarted.\n\nEvent emitted after `restart()` is called with array of worker IDs that will be\nrestarted.\n\n### \'restart\'\n\nEvent emitted after after all the workers have been restarted.\n\n### \'stopWorker\'\n\n* `worker` {Worker object}\n* `code` {Number} the exit code, if it exited normally.\n* `signal` {String} the name of the signal if it exited due to signal\n\nEvent emitted after a worker which was shutdown during a resize exits, see the node\nAPI documentation for a description of `worker`.\n\nThe values of `code` and `signal`, as well as of `worker.suicide`, can be used\nto determine how gracefully the worker was stopped. See `.terminate()`.\n',
       filename: 'api.md',
       sections: [Object],
       classes: [],
       methods: [],
       properties: [],
       commentTemplate: '<section class="code-doc <%= ann.isClass ? \'code-class\' : \'\' %>">\n  <a name="<%= ann.anchor %>"></a>\n  <h<%= section.depth %> class="code-ref"><%= ann.header %></h<%= section.depth %>>\n  <% if(ann.classDesc) { %>\n    <h<%= section.depth + 1 %> class="code-class-desc"><%= ann.classDesc %></h<%= section.depth + 1 %>>\n  <% } %>\n    <% if(ann.moduleExample) { %>\n    <h<%= section.depth + 1 %> class="code-module-example"><%= ann.moduleExample %></h<%= section.depth + 1 %>>\n  <% } %>\n  <div class="code-desc">\n    <%- ann.html %>\n  </div>\n  <% if(Array.isArray(ann.args) && ann.args.length) { %>\n    <div class="code-arguments-hdr">Arguments</div>\n    <table class="params code-arguments">\n      <tr>\n        <th class="hdr-name">Name</th>\n        <th class="hdr-type">Type</th>\n        <th class="hdr-desc">Description</th>\n      </tr>\n      <%\n      ann.args.forEach(function (arg) {\n        renderArg(arg);\n      })\n      %>\n    </table>\n    <%\n\n      ann.args.forEach(function (arg) {\n        if(arg.type === \'options\' && arg.properties.length) {\n          %>\n          <div class="code-arguments-hdr"><%= arg.name || \'Options\' %></div>\n          <table class="params code-arg-options">\n            <tr>\n              <th class="hdr-name">Name</th>\n              <th class="hdr-type">Type</th>\n              <th class="hdr-desc">Description</th>\n            </tr>\n          <%\n          arg.properties.forEach(renderArg);\n          %>\n          </table>\n          <%\n        } else if(arg.type === \'callback\' && arg.args.length) {\n          %>\n          <div class="code-arguments-hdr"><%= arg.name || \'Callback\' %></div>           \n          <table class="params code-callback-args">\n          <tr>\n            <th class="hdr-name">Name</th>\n            <th class="hdr-type">Type</th>\n            <th class="hdr-desc">Description</th>\n          </tr>\n          <%\n          arg.args.forEach(renderArg);\n          %>\n          </table>\n          <%\n        }\n      })\n    %>\n\n  <% } %>\n  \n    <% if(Array.isArray(ann.properties) && ann.properties.length) { %>\n    <div class="code-arguments-hdr">Class Properties</div>\n    <table class="params code-arguments">\n      <tr>\n        <th class="hdr-name">Name</th>\n        <th class="hdr-type">Type</th>\n        <th class="hdr-desc">Description</th>\n      </tr>\n      <%\n      ann.properties.forEach(function (arg) {\n        renderArg(arg);\n      })\n      %>\n    </table>\n    <%\n      ann.properties.forEach(function (arg) {\n        if(arg.type === \'options\' && arg.properties.length) {\n          %>\n          <div class="code-arguments-hdr"><%= arg.name || \'Options\' %></div>\n          <table class="params code-arg-options">\n            <tr>\n              <th class="hdr-name">Name</th>\n              <th class="hdr-type">Type</th>\n              <th class="hdr-desc">Description</th>\n            </tr>\n          <%\n          arg.properties.forEach(renderArg);\n          %>\n          </table>\n          <% } \n      })\n }\n %> \n\n  <% if(ann.attrs.returns) { %>\n    <div class="code-arguments-hdr">Returns</div>\n    <table class="params code-callback-args">\n      <tr>\n        <th class="hdr-name">Name</th>\n        <th class="hdr-type">Type</th>\n        <th class="hdr-desc">Description</th>\n      </tr>\n      <% renderArg(ann.attrs.returns) %>\n    </table>\n  <% } %>\n  \n  <% if(ann.attrs.example) {%> \n    <div class="code-arguments-hdr">Example</div>\n    <div class="example">\n      <%- md(ann.attrs.example) %>\n    </div>\n  <% } %>\n</section>\n\n\n<% function renderArg(arg) { %>\n  <tr class="code-arg">\n      <td>\n        <strong class="code-arg-name"><%= arg.name %></strong>\n      </td>\n      <td class="code-arg-types">\n        <% if(arg.types) { %>\n          <code><%= arg.types.join(\' or \') %></code>\n        <% } else if(arg.type) { %>\n          <code><%= arg.type %></code>\n        <% } %>\n      </td>\n    <td class="code-arg-desc">\n      <%- arg.description || \'\' %>\n    </td>\n  </tr>\n<% } %>\n',
       html: '<a name="overview"></a><h2 id="overview">Overview</h2>\n<p>The controller is exported by the <code>strong-cluster-control</code> module.</p>\n<pre><code>control = require(&#39;strong-cluster-control&#39;)</code></pre>\n<a name="methods"></a><h2 id="methods">Methods</h2>\n<a name="control-startoptionscallback"></a><h3 id="control-start-options-callback-">control.start([options],[callback])</h3>\n<p>Start the controller.</p>\n<ul>\n<li><code>options</code>: {Object} An options object, see below for supported properties,\nno default, and options object is not required.</li>\n<li><code>callback</code>: {Function} A callback function, it is set as a listener for\nthe <code>&#39;start&#39;</code> event.</li>\n</ul>\n<p>The options are:</p>\n<ul>\n<li><p><code>size</code>: {Integer} Number of workers that should be running, the default\nis to <em>not</em> control the number of workers, see <code>setSize()</code></p>\n</li>\n<li><p><code>env</code>: {Object} Environment properties object passed to <code>cluster.fork()</code> if\nthe controller has to start a worker to resize the cluster, default is null.</p>\n</li>\n<li><p><code>shutdownTimeout</code>: {Milliseconds} Number of milliseconds to wait after\nshutdown before terminating a worker, the default is 5 seconds, see\n<code>.shutdown()</code></p>\n</li>\n<li><code>terminateTimeout</code>: {Milliseconds} Number of milliseconds to wait after\nterminate before killing a worker, the default is 5 seconds, see\n<code>.terminate()</code></li>\n<li><code>throttleDelay</code>: {Milliseconds} Number of milliseconds to delay restarting\n workers after they are exiting abnormally.  Abnormal is defined as\n as <em>not</em> suicide, see <code>worker.suicide</code> in\n <a href="http://nodejs.org/docs/latest/api/cluster.html">cluster docs</a></li>\n</ul>\n<p>For convenience during setup, it is not necessary to wrap <code>.start()</code> in a protective\nconditional <code>if(cluster.isMaster) {control.start()}</code>, when called in workers it quietly\ndoes nothing but call its callback.</p>\n<p>The &#39;start&#39; event is emitted after the controller is started.</p>\n<a name="control-stopcallback"></a><h3 id="control-stop-callback-">control.stop([callback])</h3>\n<p>Stop the controller, after stopping workers (if the size is being controlled,\nsee <code>setSize()</code>).</p>\n<p>Remove event listeners that were set on the <code>cluster</code> module.</p>\n<ul>\n<li><code>callback</code>: {Function} A callback function, it is set as a listener for\nthe <code>&#39;stop&#39;</code> event.</li>\n</ul>\n<p>The &#39;stop&#39; event is emitted after the controller is stopped.</p>\n<p>When there are no workers or listeners, node will exit, unless the application\nhas non-cluster handles open. Open handles can be closed in the &#39;stop&#39; event\ncallback to allow node to shutdown gracefully, or <code>process.exit()</code> can be\ncalled, as appropriate for the application.</p>\n<a name="control-restart"></a><h3 id="control-restart-">control.restart()</h3>\n<p>Restart workers one by one, until all current workers have been restarted.</p>\n<p>This can be used to do a rolling upgrade, if the underlying code has changed.</p>\n<p>Old workers will be restarted only if the last worker to be restarted stays\nalive for more than <code>throttleDelay</code> milliseconds, ensuring that the current\nworkers will not all be killed while the new workers are failing to start.</p>\n<a name="control-loadoptionsdefaults"></a><h3 id="control-loadoptions-defaults-">control.loadOptions([defaults])</h3>\n<p>Load options from configuration files, environment, or command line.</p>\n<ul>\n<li><code>defaults</code>: {Object} Default options, see <code>start()</code> for description\nof supported options.</li>\n</ul>\n<p>An options object is returned that is suitable for passing directly to\n<code>start()</code>. How you use it is up to you, but it can be conveniently used to\nimplement optionally clustered applications, ones that run unclustered when\ndeployed as single instances, perhaps behind a load balancer, or that can be\ndeployed as a node cluster.</p>\n<p>Here is an example of the above usage pattern:</p>\n<pre><code>// app.js\nvar control = require(&#39;strong-cluster-control&#39;);\nvar options = control.loadOptions();\nif(options.clustered &amp;&amp; options.isMaster) {\n    return control.start(options);\n}\n\n// Server setup... or any work that should be done in the master if\n// the application is not being clustered, or in the worker if it\n// is being clustered.</code></pre>\n<p>The options values are derived from the following configuration sources:</p>\n<ul>\n<li>command line arguments (parsed by optimist): if your app ignores unknown\noptions, options can be set on the command line, ex. <code>node app.js --size=2</code></li>\n<li>environment variables prefixed with <code>cluster_</code>: note that the variable must be\nlower case, ex. <code>cluster_size=2 node app.js</code></li>\n<li><code>.clusterrc</code> in either json or ini format: can be in the current working\ndirectory, or any parent paths</li>\n<li><code>defaults</code>: as passed in, if any</li>\n</ul>\n<p>This is actually a subset of the possible locations, the\n<a href="https://npmjs.org/package/rc">rc</a> module is used with an <code>appname</code> of\n&quot;cluster&quot;, see it&#39;s documentation for more information.</p>\n<p>Supported values are those described in <code>start()</code>, with a few extensions for\n<code>size</code>, which may be one of:</p>\n<ol>\n<li><code>0</code> - <code>N</code>, a positive integer, cluster size to maintain, as for <code>start()</code></li>\n<li><code>&quot;default&quot;</code>, or a string containing <code>&quot;cpu&quot;</code>, this will be converted to the\nnumber of cpus, see <code>control.CPUS</code></li>\n<li><code>&quot;off&quot;</code>, or anything else that isn&#39;t one of the previous values will indicate\na preference for <em>not</em> clustering</li>\n</ol>\n<p>The returned options object will contain the following fields that are not\noptions to <code>start()</code>:</p>\n<ul>\n<li>clustered: false if size is 0 (after above conversions), true if a cluster\nsize was specified</li>\n<li>isMaster, isWorker: identical to the properties of the same name in the\ncluster module</li>\n</ul>\n<p>The combination of the above three allows you to determine if you are a worker,\nor not, and if you are a master, if you should start the cluster control module,\nor just start the server if clustering was not requested.</p>\n<a name="control-status"></a><h3 id="control-status-">control.status()</h3>\n<p>Returns the current cluster status. Its properties include:</p>\n<ul>\n<li><code>master</code>: {Object}<ul>\n<li><code>pid</code>: The pid of the Master process.</li>\n</ul>\n</li>\n<li><code>workers</code>: {Array} An Array of Objects containining the following properties:<ul>\n<li><code>id</code>: The id of the Worker within the Master.</li>\n<li><code>pid</code>: The pid of the Worker process.</li>\n</ul>\n</li>\n</ul>\n<a name="control-setsizen"></a><h3 id="control-setsize-n-">control.setSize(N)</h3>\n<p>Set the size of the cluster.</p>\n<ul>\n<li><code>N</code>: {Integer or null} The size of the cluster is the number of workers\nthat should be maintained online. A size of <code>null</code> clears the size, and\ndisables the size control feature of the controller.</li>\n</ul>\n<p>The cluster size can be set explicitly with <code>setSize()</code>, or implicitly through\nthe <code>options</code> provided to <code>.start()</code>, or through the control channel.</p>\n<p>The size cannot be set until the controller has been started, and will not be\nmaintained after the cluster has stopped.</p>\n<p>Once set, the controller will listen on cluster <code>fork</code> and <code>exit</code> events,\nand resize the cluster back to the set size if necessary. After the cluster has\nbeen resized, the &#39;resize&#39; event will be emitted.</p>\n<p>When a resize is necessary, workers will be started or stopped one-by-one until\nthe cluster is the set size.</p>\n<p>Cluster workers are started with <code>cluster.fork(control.options.env)</code>, so the\nenvironment can be set, but must be the same for each worker. After a worker has\nbeen started, the &#39;startWorker&#39; event will be emitted.</p>\n<p>Cluster workers are stopped with <code>.shutdown()</code>. After a worker has been stopped,\nthe &#39;stopWorker&#39; event will be emitted.</p>\n<a name="control-shutdownid"></a><h3 id="control-shutdown-id-">control.shutdown(id)</h3>\n<p>Disconnect worker <code>id</code> and take increasingly agressive action until it exits.</p>\n<ul>\n<li><code>id</code> {Number} Cluster worker ID, see <code>cluster.workers</code> in\n<a href="http://nodejs.org/docs/latest/api/cluster.html">cluster docs</a></li>\n</ul>\n<p>The effect of disconnect on a worker is to close all the servers in the worker,\nwait for them to close, and then exit. This process may not occur in a timely\nfashion if, for example, the server connections do not close. In order to\ngracefully close any open connections, a worker may listen to the <code>SHUTDOWN</code>\nmessage, see <code>control.cmd.SHUTDOWN</code>.</p>\n<p>Sends a <code>SHUTDOWN</code> message to the identified worker, calls\n<code>worker.disconnect()</code>, and sets a timer for <code>control.options.shutdownTimeout</code>.\nIf the worker has not exited by that time, calls <code>.terminate()</code> on the worker.</p>\n<a name="control-terminateid"></a><h3 id="control-terminate-id-">control.terminate(id)</h3>\n<p>Terminate worker <code>id</code>, taking increasingly aggressive action until it exits.</p>\n<ul>\n<li><code>id</code> {Number} Cluster worker ID, see <code>cluster.workers</code> in\n<a href="http://nodejs.org/docs/latest/api/cluster.html">cluster docs</a></li>\n</ul>\n<p>The effect of sending SIGTERM to a node process should be to cause it to exit.\nThis may not occur in a timely fashion if, for example, the process is ignoring\nSIGTERM, or busy looping.</p>\n<p>Calls <code>worker.kill(&quot;SIGTERM&quot;)</code> on the identified worker, and sets a timer for\n<code>control.options.terminateTimeout</code>. If the worker has not exited by that time,\ncalls <code>worker.(&quot;SIGKILL&quot;)</code> on the worker.</p>\n<a name="properties"></a><h2 id="properties">Properties</h2>\n<a name="control-options"></a><h3 id="control-options">control.options</h3>\n<p>A copy of the options set by calling <code>.start()</code>.</p>\n<p>It will have any default values set in it, and will be kept synchronized with\nchanges made via explicit calls, such as to <code>.setSize()</code>.</p>\n<p>Visible for diagnostic and logging purposes.  Do <em>not</em> modify the options\ndirectly.</p>\n<a name="control-cmd-shutdown"></a><h3 id="control-cmd-shutdown">control.cmd.SHUTDOWN</h3>\n<ul>\n<li>{String} <code>&#39;CLUSTER_CONTROL_shutdown&#39;</code></li>\n</ul>\n<p>The <code>SHUTDOWN</code> message is sent by <code>.shutdown()</code> before disconnecting the worker,\nand can be used to gracefully close any open connections before the\n<code>control.options.shutdownTimeout</code> expires.</p>\n<p>All connections will be closed at the TCP level when the worker exits or is\nterminated, but this message gives the opportunity to close at a more\napplication-appropriate time, for example, after any outstanding requests have\nbeen completed.</p>\n<p>The message format is:</p>\n<pre><code>{ cmd: control.cmd.SHUTDOWN }</code></pre>\n<p>It can be received in a worker by listening for a <code>&#39;message&#39;</code> event with a\nmatching <code>cmd</code> property:</p>\n<pre><code>process.on(&#39;message&#39;, function(msg) {\n    if(msg.cmd === control.cmd.SHUTDOWN) {\n        // Close any open connections as soon as they are idle...\n    }\n});</code></pre>\n<a name="control-cpus"></a><h3 id="control-cpus">control.CPUS</h3>\n<p>The number of CPUs reported by node&#39;s <code>os.cpus().length</code>, this is a good default\nfor the cluster size, in the absence of application specific analysis of what\nwould be an optimal number of workers.</p>\n<a name="events"></a><h2 id="events">Events</h2>\n<a name="start"></a><h3 id="-start-">&#39;start&#39;</h3>\n<p>Event emitted after control has started. Control is considered started\nafter the &#39;listening&#39; event has been emitted.</p>\n<p>Starting of workers happens in the background, if you are specifically\ninterested in knowing when all the workers have started, see the &#39;resize&#39;\nevent.</p>\n<a name="stop"></a><h3 id="-stop-">&#39;stop&#39;</h3>\n<p>Event emitted after control has stopped, see <code>.stop()</code>.</p>\n<a name="error"></a><h3 id="-error-">&#39;error&#39;</h3>\n<ul>\n<li>{Error Object}</li>\n</ul>\n<p>Event emitted when an error occurs. The only current source of errors is the control\nprotocol, which may require logging of the errors, but should not effect the\noperation of the controller.</p>\n<a name="setsize"></a><h3 id="-setsize-">&#39;setSize&#39;</h3>\n<ul>\n<li>{Integer} size, the number of workers requested (will always\nbe the same as <code>cluster.options.size</code>)</li>\n</ul>\n<p>Event emitted after <code>setSize()</code> is called.</p>\n<a name="resize"></a><h3 id="-resize-">&#39;resize&#39;</h3>\n<ul>\n<li>{Integer} size, the number of workers now that resize is complete (will always\nbe the same as <code>cluster.options.size</code>)</li>\n</ul>\n<p>Event emitted after a resize of the cluster is complete. At this point, no more\nworkers will be forked or shutdown by the controller until either the size is\nchanged or workers fork or exit, see <code>setSize()</code>.</p>\n<a name="startworker"></a><h3 id="-startworker-">&#39;startWorker&#39;</h3>\n<ul>\n<li><code>worker</code> {Worker object}</li>\n</ul>\n<p>Event emitted after a worker which was started during a resize comes online, see the\nnode API documentation for description of <code>worker</code> and &quot;online&quot;.</p>\n<a name="startrestart"></a><h3 id="-startrestart-">&#39;startRestart&#39;</h3>\n<ul>\n<li><code>workers</code> {Array of worker IDs} Workers that are going to be restarted.</li>\n</ul>\n<p>Event emitted after <code>restart()</code> is called with array of worker IDs that will be\nrestarted.</p>\n<a name="restart"></a><h3 id="-restart-">&#39;restart&#39;</h3>\n<p>Event emitted after after all the workers have been restarted.</p>\n<a name="stopworker"></a><h3 id="-stopworker-">&#39;stopWorker&#39;</h3>\n<ul>\n<li><code>worker</code> {Worker object}</li>\n<li><code>code</code> {Number} the exit code, if it exited normally.</li>\n<li><code>signal</code> {String} the name of the signal if it exited due to signal</li>\n</ul>\n<p>Event emitted after a worker which was shutdown during a resize exits, see the node\nAPI documentation for a description of <code>worker</code>.</p>\n<p>The values of <code>code</code> and <code>signal</code>, as well as of <code>worker.suicide</code>, can be used\nto determine how gracefully the worker was stopped. See <code>.terminate()</code>.</p>\n' } ],
  sections: 
   [ { title: 'Overview', depth: 2, anchor: 'overview' },
     { title: 'Methods', depth: 2, anchor: 'methods' },
     { title: 'control.start',
       depth: 3,
       anchor: 'control-startoptionscallback' },
     { title: 'control.stop',
       depth: 3,
       anchor: 'control-stopcallback' },
     { title: 'control.restart', depth: 3, anchor: 'control-restart' },
     { title: 'control.loadOptions',
       depth: 3,
       anchor: 'control-loadoptionsdefaults' },
     { title: 'control.status', depth: 3, anchor: 'control-status' },
     { title: 'control.setSize',
       depth: 3,
       anchor: 'control-setsizen' },
     { title: 'control.shutdown',
       depth: 3,
       anchor: 'control-shutdownid' },
     { title: 'control.terminate',
       depth: 3,
       anchor: 'control-terminateid' },
     { title: 'Properties', depth: 2, anchor: 'properties' },
     { title: 'control.options', depth: 3, anchor: 'control-options' },
     { title: 'control.cmd.SHUTDOWN',
       depth: 3,
       anchor: 'control-cmd-shutdown' },
     { title: 'control.CPUS', depth: 3, anchor: 'control-cpus' },
     { title: 'Events', depth: 2, anchor: 'events' },
     { title: '&#39;start&#39;', depth: 3, anchor: 'start' },
     { title: '&#39;stop&#39;', depth: 3, anchor: 'stop' },
     { title: '&#39;error&#39;', depth: 3, anchor: 'error' },
     { title: '&#39;setSize&#39;', depth: 3, anchor: 'setsize' },
     { title: '&#39;resize&#39;', depth: 3, anchor: 'resize' },
     { title: '&#39;startWorker&#39;',
       depth: 3,
       anchor: 'startworker' },
     { title: '&#39;startRestart&#39;',
       depth: 3,
       anchor: 'startrestart' },
     { title: '&#39;restart&#39;', depth: 3, anchor: 'restart' },
     { title: '&#39;stopWorker&#39;', depth: 3, anchor: 'stopworker' } ],
  root: '/home/sam/w/sn/strong-cluster-control',
  config: 
   { content: [ 'api.md' ],
     package: 
      { name: 'strong-cluster-control',
        version: '1.0.0',
        description: 'node cluster API wrapper and extensions',
        license: [Object],
        keywords: [Object],
        main: 'index.js',
        scripts: [Object],
        repository: [Object],
        author: [Object],
        dependencies: [Object],
        devDependencies: [Object],
        engines: [Object] },
     extensions: [ '.markdown', '.md', '.js' ],
     fileSections: true },
  commentTemplate: '<section class="code-doc <%= ann.isClass ? \'code-class\' : \'\' %>">\n  <a name="<%= ann.anchor %>"></a>\n  <h<%= section.depth %> class="code-ref"><%= ann.header %></h<%= section.depth %>>\n  <% if(ann.classDesc) { %>\n    <h<%= section.depth + 1 %> class="code-class-desc"><%= ann.classDesc %></h<%= section.depth + 1 %>>\n  <% } %>\n    <% if(ann.moduleExample) { %>\n    <h<%= section.depth + 1 %> class="code-module-example"><%= ann.moduleExample %></h<%= section.depth + 1 %>>\n  <% } %>\n  <div class="code-desc">\n    <%- ann.html %>\n  </div>\n  <% if(Array.isArray(ann.args) && ann.args.length) { %>\n    <div class="code-arguments-hdr">Arguments</div>\n    <table class="params code-arguments">\n      <tr>\n        <th class="hdr-name">Name</th>\n        <th class="hdr-type">Type</th>\n        <th class="hdr-desc">Description</th>\n      </tr>\n      <%\n      ann.args.forEach(function (arg) {\n        renderArg(arg);\n      })\n      %>\n    </table>\n    <%\n\n      ann.args.forEach(function (arg) {\n        if(arg.type === \'options\' && arg.properties.length) {\n          %>\n          <div class="code-arguments-hdr"><%= arg.name || \'Options\' %></div>\n          <table class="params code-arg-options">\n            <tr>\n              <th class="hdr-name">Name</th>\n              <th class="hdr-type">Type</th>\n              <th class="hdr-desc">Description</th>\n            </tr>\n          <%\n          arg.properties.forEach(renderArg);\n          %>\n          </table>\n          <%\n        } else if(arg.type === \'callback\' && arg.args.length) {\n          %>\n          <div class="code-arguments-hdr"><%= arg.name || \'Callback\' %></div>           \n          <table class="params code-callback-args">\n          <tr>\n            <th class="hdr-name">Name</th>\n            <th class="hdr-type">Type</th>\n            <th class="hdr-desc">Description</th>\n          </tr>\n          <%\n          arg.args.forEach(renderArg);\n          %>\n          </table>\n          <%\n        }\n      })\n    %>\n\n  <% } %>\n  \n    <% if(Array.isArray(ann.properties) && ann.properties.length) { %>\n    <div class="code-arguments-hdr">Class Properties</div>\n    <table class="params code-arguments">\n      <tr>\n        <th class="hdr-name">Name</th>\n        <th class="hdr-type">Type</th>\n        <th class="hdr-desc">Description</th>\n      </tr>\n      <%\n      ann.properties.forEach(function (arg) {\n        renderArg(arg);\n      })\n      %>\n    </table>\n    <%\n      ann.properties.forEach(function (arg) {\n        if(arg.type === \'options\' && arg.properties.length) {\n          %>\n          <div class="code-arguments-hdr"><%= arg.name || \'Options\' %></div>\n          <table class="params code-arg-options">\n            <tr>\n              <th class="hdr-name">Name</th>\n              <th class="hdr-type">Type</th>\n              <th class="hdr-desc">Description</th>\n            </tr>\n          <%\n          arg.properties.forEach(renderArg);\n          %>\n          </table>\n          <% } \n      })\n }\n %> \n\n  <% if(ann.attrs.returns) { %>\n    <div class="code-arguments-hdr">Returns</div>\n    <table class="params code-callback-args">\n      <tr>\n        <th class="hdr-name">Name</th>\n        <th class="hdr-type">Type</th>\n        <th class="hdr-desc">Description</th>\n      </tr>\n      <% renderArg(ann.attrs.returns) %>\n    </table>\n  <% } %>\n  \n  <% if(ann.attrs.example) {%> \n    <div class="code-arguments-hdr">Example</div>\n    <div class="example">\n      <%- md(ann.attrs.example) %>\n    </div>\n  <% } %>\n</section>\n\n\n<% function renderArg(arg) { %>\n  <tr class="code-arg">\n      <td>\n        <strong class="code-arg-name"><%= arg.name %></strong>\n      </td>\n      <td class="code-arg-types">\n        <% if(arg.types) { %>\n          <code><%= arg.types.join(\' or \') %></code>\n        <% } else if(arg.type) { %>\n          <code><%= arg.type %></code>\n        <% } %>\n      </td>\n    <td class="code-arg-desc">\n      <%- arg.description || \'\' %>\n    </td>\n  </tr>\n<% } %>\n',
  anchors: 
   { overview: true,
     methods: true,
     'control-startoptionscallback': true,
     'control-stopcallback': true,
     'control-restart': true,
     'control-loadoptionsdefaults': true,
     'control-status': true,
     'control-setsizen': true,
     'control-shutdownid': true,
     'control-terminateid': true,
     properties: true,
     'control-options': true,
     'control-cmd-shutdown': true,
     'control-cpus': true,
     events: true,
     start: true,
     stop: true,
     error: true,
     setsize: true,
     resize: true,
     startworker: true,
     startrestart: true,
     restart: true,
     stopworker: true } }
